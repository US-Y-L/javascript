# 运算符

运算符也叫操作符

通过运算符可以对 一个值 或 多个值 进行运算，运算符都会返回相应的结果

typeof就是一个一元运算符，可以用来获取一个值的类型，并将该值的类型以字符串的形式返回

## 算数运算符

​		运算符都不会对原变量产生影响，当对非Number类型的值进行运算时，会先将该类型转换为Number类型再进行运算

​		任何值与NaN做运算最后结果都是NaN

​		

+加法运算

​	对两个值进行加法运算，并将结果返回

​	如果对两个字符串进行操作，则会进行字符串拼接，即将两个字符串拼接为一个字符串，并返回这个新的字符串

​	任何值 和字符串做加法运算，都会先转换为字符串，然后再和字符串进行拼串操作

​			因此，只要为任意的数据类型加一个“ ”(空的字符串)，即可将该类型转换为String类型，这是一种**隐式转换**，由浏览器自动完成，实际上他也是调用了String()函数

例：和字符串的加法：

​		var result = 1 + 2 + "3";

​    	console.log("result="+result);  此时输出结果为“33”，因为运算顺序是从左向右的 

### 	除了加法有隐式转换，其他运算方法没有隐式转换的功能，都是先将其他数据类型转换为Number类型再进行运算

​		因此将其他数据类型进行 -0、*1、/1 运算可以将其自动转换为Number类型，了解就好。不像+的隐式转换用的频繁

-减法运算

*乘法运算

/除法运算

%取模运算(取余数) 返回的是余数

​		例：

​		var num1 = 9 % 4;

   	console.log("num1=" +num1);  此时运算结果返回的是1



# 一元运算符

只需要一个操作数，也可以理解为只需要一个参数

+正号

​		正号不会对数值产生任何影响

-负号

​		符号可以对数字进行符号的取反  正变负，负变正



对非Number类型的值，会先将其转换为Number类型，再进行运算

因此可以对其他的数据类型前加一个+，便可将其他数据类型转换为Number类型。他的原理和Number函数一样，但是更加方便



# 自增和自减

## 自增    ++两个加号

​		通过自增可以使变量在自身基础上增加1

​		对于一个变量自增以后，原变量的值会立即自增1，每调一次，原变量在原来的基础上加1

​		自增分为两种：  后++(变量++)  和   前++(++变量)

​		两种方法都会使**原变量**的值自增1

​		但是 变量++  和  ++变量 的值不同：

​				变量++ 的值等于原变量的值(先输出在运算)

​				++变量的值等于原变量自增后的值、新值(先运算再输出)

​					var aa = 10;

​					 aa++;

​					 console.log(aa++); //此时输出的aa++的值为11

​    				console.log(aa);  //此时输出的aa值为12



​					var d = 20

​					var result = d++ + ++d + d;    此时输出的result值为64

​										20       22      22    = 64

## 自减   --两个减号

***用法同自增。***

自减也是分成两种：

​		后--(变量--) 和 前--(--变量)

无论是后-- 和 前-- 都会立即使原变量的值自减1

​		但是 后--  和  前--的值不同

​		后-- 使变量的原值，即自减前的值

​		而前--使变量的新值，即自减前的值



# 逻辑运算符

## JS中有三种逻辑运算符

### ! 非

​	可以用来对一个值进行非运算 

​	所谓非运算就是对一个布尔值进行取反操作

​		var bb = true;

​    	//再给变量bb进行取反并赋值

   	 bb = !bb;

   	 console.log(bb);     此时打印出的变量bb就是 false

​	对一个值进行两次取反，这个值不会变化

**对非布尔值进行取反运算，则会将其转换为布尔值，然后再取反**   所以可以对一个任意数据类型进行**两次取反**，来将其数据类型转换为Boolean类型，原理同Boolean()函数

### && 与

​	可以对符号两侧的值进行与运算，并返回结果

​	运算规则：

​		如果前后两个值都是true则返回true

​		只要有一个false就返回false

​	JS中的“与运算”属于短路的与，如果第一个值为false,则不再去看第二个值，直接返回false。第一个值为true才回去检查第二个值

例：

​	true && alert(“123”)    会弹出123

​	false && alert(“123”)  不会弹出123

### || 或

​	同样的对符号两侧的值进行或运算，并返回结果

​	运算规则：

​		两个值中只要有一个true就返回true

​		如果两个值都为false才返回false

JS中的“或运算”也属于短路的 或 ，如果第一个值是true，就不再去看检查第二个值，直接返回true.第一个值为false才回去检查第二个值

例：

​	false || alert(“123”)   会弹出123

​	true || alert(“123”)   不会弹出123

## 非布尔值的与或运算



​		对于非布尔值的数据类型进行与或运算时，会先将其转换为布尔值，然后再进行运算。并且返回**原值**

**与运算：**  &&

​			如果两个值都是true，则返回后面的内容.如果第一个值是false,则不看后面的内容，直接返回为第一个为false的那个内容

规则：如果第一个值是true,则必然返回第二个值

​		  如果第一个值是false,则必然返回第一个值

**或运算**     ||

​			第一个值为true，则直接返回第一个值。

​			第一个值为false，则直接返回第二个值



# 赋值运算符

=   可以将符号右侧的值赋值给符号左侧的变量

+=    a += 5的效果等价于 a = a + 5    +=是一个完整的符号，不能隔开

-=     a -= 5 的效果等价于  a = a - 5   

*=     a *= 5  的效果等价于  a = a *5

/=    a /=  5  的效果等价于  a = a / 5

%=  a  %= 5 的效果等价于  a = a % 5



# 关系运算符

通过关系运算符可以比较两个值之间的大小关系。

如果关系成立会返回true,关系不成立则会返回false



\> 大于号

判断符号左侧的值是否大于右侧的

如果关系成立，返回true;不成立则返回false



\>=   大于等于

 判断符号左侧的值是否大于或等于右侧的值

关系成立返回true,不成立则返回false



\<   小于

判断符号左侧的值是否小于右侧的值



\<=  小于等于

判断符号左侧的值是否小于等于右侧的值



## 非数值的情况

对非数值进行比较时，会先将其转换为数字类型，然后再进行比较

任何值和NaN做任何比较结果都是 false

​		如果**符号两边**的值都是**字符串**，不会将其转换为数字进行比较，而会分别比较字符串中字符的Unicode编码

​		比较字符串时是一位以为进行比较的，如果前面的的两位一样，则比较下一位。如果前面的两位不同，则可以直接分辨出大小。借用它可以实现英文字母的排序     比较中文时没有意义

​		如果比较的是两个字符串型的数字，可能的到不可预期的结果，如果两个都是字符串，一定要转为数字类型(转其中一个就好)



### 使用Unicode编码

**JS中使用Unicode编码**

​		在字符串中用转义字符输入Unicode编码

​		\u四位编码   即可使用Unicode编码来输出对应的内容      此时需要的是16进制的

**在网页(body)中使用Unicode编码**

​		使用转义字符，类似实体一样的形式

​		&#编码;    

​		 此时需要的是10进制的,Unicode中的编码都是16进制的，用时需要转换为10进制



# 相等运算符

想等运算符用来比较两个值是否相等

如果相等返回true,不相等则返回false

== 相等

​	当使用==来比较两个值时，如果两个值类型不同，会先将其转换为相同类型，然后再进行比较。大部分情况下都是转换为Number类型 

​	console.log(true == “1”)    打印的结果时true,此时是将true和字符串1都转换为了Number类型



Undefined衍生自Null，所以这两个值做相等判断时，会返回true



NaN不和任何值相等，包括他本身。

可以通过 isNaN()函数来判断一个值是不是NaN,如果是NaN就返回true;否则返回false



!=  不相等

用来判断两个值是否不相等，如果不相等返回true.相等则返回false

使用!=来做不想等运算

不相等运算也会进行自动的类型转换，如果转换后相等也会返回false



=== 全等

全等用来判断两个值是否全等，和想等类似，但是不会做自动的类型转换，如果两个值的类型不同们直接返回false

=== 要求**类型**和**数值大小**都要**相同**



!==  不全等

用来判断两个值是否不全等，和!=类似。不会做类型转换，

类型不同也会返回true



# 条件运算符

条件运算符也叫三元运算符

语法：

​		条件表达式?语句1:(冒号)语句2;(分号)

执行流程：

​		条件运算符在执行时，首先对条件表达式进行求值

​		如果该值为true，则执行语句1 ，并返回执行结果

​		如过该值为false，则执行语句2，并返回执行结果



使用三元运算符的到三个数中的最大值

```javascript
		var x = 30;
        var y = 40;
        var z = 50;

        var max = a > b ? (a > c ? a : c) : (b > c ? b : c);
```

三元运算符中套三元运算符，但是不方便阅读，记得加括号，便于后续阅读



如果条件表达式的求值结果是一个非布尔值，会先将其转换为布尔值再进行运算



# 运算符的优先级

, (逗号)运算符

使用,可以分割多个语句，一般在声明多个变量时使用

使用,运算符可以同时声明多个变量

```javascript
var a = 1; var b = 2; var c = 3;
//可以写成：
var a=1 , b=2 , c=3;
//效果相同
```



在JS中有一个运算优先级的表

在表中越靠上优先级越高，优先级越高越优先运算

如果优先级一样则从左向右计算

![](C:\Users\LJX1129\Pictures\Camera Roll\JS运算符优先级.png)

 

加了括号的运算能提高优先级，想有限计算哪一步就在那一步外加个()，就可优先计算		